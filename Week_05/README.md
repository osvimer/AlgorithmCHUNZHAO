学习笔记

字典树 Trie
又称单词查找树或键树；典型应用是用于统计和排序大量的字符串（但不限于字符串）
所以通常被搜索引擎系统用于文本词频统计。
优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

基本性质:
1. 每个结点只存单个的字符而非完整单词
2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串
3. 每个结点的所有子结点路径代表的字符都不相同

Trie 树的核心思想是空间换时间。
利用字符串的公共前缀来降低查询的时间开销以达到提高效率的目的。


二叉树的深度和高度
高度: 从结点到其叶子结点的最大路径长度 +1 (叶子结点的高度为 1）
深度: 从根结点到当前结点的路径长度 + 1 （根结点的深度为 1）

二叉搜索树 Binary Search Tree
也称有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree）
指一棵空树或者具有下列性质的二叉树：
1. 左子树上所有结点的值均小于它的根结点的值
2. 右子树上所有结点的值均大于它的根结点的值
3. 以此递推：左右子树也分别为二叉查找树
重要性质：二叉查找树的中序遍历是升序遍历


普通的二叉搜索树容易发生性能蜕化，在极端的情况下蜕化成一维链表。
保证性能的关键：保证二维维度 -> 左右子树结点平衡 (recursively)
由此引申出 "平衡二叉树" (Balanced Binary Search Tree) 的概念。


平衡二叉树的种类

I. AVL 树
发明者 G.M.Adelson-Velsky 和 Evgenii Landis
平衡因子 (Balance Factor) 是它的左子树的高度减去它右子树的高度（有时相反）
每个结点都存储平衡因子 balanced factor = {-1, 0, 1}
(注意这里是高度差，并不是结点数目，因为二叉搜索树的查找效率仅与其高度相关)
当平衡因子的绝对值大于 1，就要进行平衡调整。
可通过旋转操作（四种）来进行调整平衡：
1) 左旋   -> 右右子树
2) 右旋   -> 左左子树
3) 左右旋 -> 左右子树
4) 右左旋 -> 右左子树
AVL 树的缺点：结点需要存储额外信息，且调整次数频繁。
注：算法面试中只需要阐述清楚 AVL 树的特征以及四种旋转操作即可。

由于 AVL 树调整太频繁，因此衍生出了近似平衡二叉树
在平衡性上妥协，以减少调整的次数（时间），在搜索性能和维护成本之间找到均衡。

II. 红黑树 Red-Black Tree
一种近似的二叉搜索树 (BST), 它能够保证任何一个结点的左右子树的高度差小于两倍。
红黑树是满足如下条件的二叉搜索树：
1. 每个结点要么是红色，要么是黑色
2. 根结点是黑色的
3. 每个叶子结点 (NIL结点，空结点）是黑色的
4. 不能有相邻接的两个红色结点
5. 从任一结点到其每个叶子节点的所有路径都包含相同数目的黑色结点。

AVL 树和红黑树的比较
1. AVL 是严格平衡搜索树，因此它搜索的效率比红黑树更高
2. 红黑树牺牲了平衡性，但是能提供更快的插入和删除操作（更少的旋转调整）
3. AVL 树的每个结点都要存储平衡因子（整型值）；
   红黑树的每个则只需要一个 bit 位来存储类别 (红色或者黑色）
4. 红黑树应用于绝大多数的语言库中（例如 C++ STL 中的 map, multimap, set, multiset)
   AVL 树则一般用于数据库的实现中（读多写少，需要更快的查找操作）


原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。
反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。
补码：反码加1称为补码。
计算机中，正数以其原码形式表达，负数以其正值的补码形式表达。

位操作

左移一位 <<
右移一位 >>
按位或   |
按位与   &
按位取反 ~
按位异或 ^

XOR 异或操作
0^0 = 1^1 = 0; 0^1 = 1^0 = 1; 可用不进位加法来理解
x ^ 0 = x
x ^ 1s = ~x // 注意 ls = ~0 (每个位都是 1）
x ^ (~x) = 1s
x ^ x = 0
c = a ^ b  ->  a ^ c = b, b ^ c = a;
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c;

指定位置的位运算：
1. 将 X 最右边的 n 位清零:        x & (~0 << n)
2. 获取 X 的第 n 位值 (0或者1):   (x >> n) & 1
3. 获取 X 的第 n 位的幂值:        x & (1 << n)
4. 仅将第 n 位置为 1:             x | (1 << n)
5. 仅将第 n 位置为 0:             x & (~(1 << n))
6. 将 x 最高位至第 n 位清零:      x & ((1 << n) - 1)

位运算实战要点
1. 判断奇偶; 位运算比模运算要快
    x % 2 == 1  -->  (x & 1) == 1
    x % 2 == 0  -->  (x & 1) == 0
2. 乘以/除以 2 的倍数
    x/2   -->   x>>1
    x/=2  -->   x>>=1
    mid=(left+right)/2  -->  mid=(left+right)>>1
3. x = x & (x-1) 清零最低位的 1
4. x & -x --> 得到最低位的 1
5. x & ~x = 0
